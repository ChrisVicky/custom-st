--- st.c
+++ st.c
@@ -2653,56 +2751,85 @@ twrite(const char *buf, int buflen, int show_ctrl)
 }
 
 void
-tresize(int col, int row)
+clearline(Line line, Glyph g, int x, int xend)
 {
 	int i;
+	g.mode = 0;
+	g.u = ' ';
+	for (i = x; i < xend; ++i) {
+		line[i] = g;
+	}
+}
+
+Line
+ensureline(Line line)
+{
+	if (!line) {
+		line = xmalloc(term.linelen * sizeof(Glyph));
+	}
+	return line;
+}
+
+void
+tresize(int col, int row)
+{
+	int i, j;
 	int minrow = MIN(row, term.row);
 	int mincol = MIN(col, term.col);
+	int linelen = MAX(col, term.linelen);
 	int *bp;
-	TCursor c;
 
-	if (col < 1 || row < 1) {
+	if (col < 1 || row < 1 || row > HISTSIZE) {
 		fprintf(stderr,
 		        "tresize: error resizing to %dx%d\n", col, row);
 		return;
 	}
 
-	/*
-	 * slide screen to keep cursor where we expect it -
-	 * tscrollup would work here, but we can optimize to
-	 * memmove because we're freeing the earlier lines
-	 */
-	for (i = 0; i <= term.c.y - row; i++) {
-		free(term.line[i]);
-		free(term.alt[i]);
+	/* Shift buffer to keep the cursor where we expect it */
+	if (row <= term.c.y) {
+		term.screen[0].cur = (term.screen[0].cur - row + term.c.y + 1) % term.screen[0].size;
+	}
+
+	/* Resize and clear line buffers as needed */
+	if (linelen > term.linelen) {
+		for (i = 0; i < term.screen[0].size; ++i) {
+			if (term.screen[0].buffer[i]) {
+				term.screen[0].buffer[i] = xrealloc(term.screen[0].buffer[i], linelen * sizeof(Glyph));
+				clearline(term.screen[0].buffer[i], term.c.attr, term.linelen, linelen);
+			}
+		}
+		for (i = 0; i < minrow; ++i) {
+			term.screen[1].buffer[i] = xrealloc(term.screen[1].buffer[i], linelen * sizeof(Glyph));
+			clearline(term.screen[1].buffer[i], term.c.attr, term.linelen, linelen);
+		}
 	}
-	/* ensure that both src and dst are not NULL */
-	if (i > 0) {
-		memmove(term.line, term.line + i, row * sizeof(Line));
-		memmove(term.alt, term.alt + i, row * sizeof(Line));
+	/* Allocate all visible lines for regular line buffer */
+	for (j = term.screen[0].cur, i = 0; i < row; ++i, j = (j + 1) % term.screen[0].size)
+	{
+		if (!term.screen[0].buffer[j]) {
+			term.screen[0].buffer[j] = xmalloc(linelen * sizeof(Glyph));
+		}
+		if (i >= term.row) {
+			clearline(term.screen[0].buffer[j], term.c.attr, 0, linelen);
+		}
 	}
-	for (i += row; i < term.row; i++) {
-		free(term.line[i]);
-		free(term.alt[i]);
+	/* Resize alt screen */
+	term.screen[1].cur = 0;
+	term.screen[1].size = row;
+	for (i = row; i < term.row; ++i) {
+		free(term.screen[1].buffer[i]);
+	}
+	term.screen[1].buffer = xrealloc(term.screen[1].buffer, row * sizeof(Line));
+	for (i = term.row; i < row; ++i) {
+		term.screen[1].buffer[i] = xmalloc(linelen * sizeof(Glyph));
+		clearline(term.screen[1].buffer[i], term.c.attr, 0, linelen);
 	}
 
 	/* resize to new height */
-	term.line = xrealloc(term.line, row * sizeof(Line));
-	term.alt  = xrealloc(term.alt,  row * sizeof(Line));
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
-	/* resize each row to new width, zero-pad if needed */
-	for (i = 0; i < minrow; i++) {
-		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
-		term.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));
-	}
-
-	/* allocate any new rows */
-	for (/* i = minrow */; i < row; i++) {
-		term.line[i] = xmalloc(col * sizeof(Glyph));
-		term.alt[i] = xmalloc(col * sizeof(Glyph));
-	}
+	/* fix tabstops */
 	if (col > term.col) {
 		bp = term.tabs + term.col;
 
